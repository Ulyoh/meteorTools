{"version":3,"sources":["/tools/packaging/catalog/catalog-local.js"],"names":[],"mappings":"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","file":"tools/packaging/catalog/catalog-local.js.map","sourcesContent":["var _ = require('underscore');\nvar buildmessage = require('../../utils/buildmessage.js');\nvar files = require('../../fs/files.js');\nvar watch = require('../../fs/watch.js');\nvar PackageSource = require('../../isobuild/package-source.js');\nimport { KNOWN_ISOBUILD_FEATURE_PACKAGES } from '../../isobuild/compiler.js';\n\n// LocalCatalog represents packages located in the application's\n// package directory, other package directories specified via an\n// environment variable, and core packages in the repo if meteor is\n// being run from a git checkout.\nvar LocalCatalog = function (options) {\n  var self = this;\n  options = options || {};\n\n  // Package server data.  Maps package name to a {packageSource, packageRecord,\n  // versionRecord} object.\n  self.packages = {};\n\n  self.initialized = false;\n\n    // Local directories to search for package source trees\n  self.localPackageSearchDirs = null;\n\n  // Package source trees added explicitly through a directory (not through a\n  // parent search directory). We mainly use this to allow the user to run\n  // test-packages against a package in a specific directory.\n  self.explicitlyAddedLocalPackageDirs = [];\n\n  // All packages found either by localPackageSearchDirs or\n  // explicitlyAddedLocalPackageDirs. There is a hierarchy of packages, as\n  // detailed below and there can only be one local version of a package at a\n  // time. This refers to the package by the specific package directory that we\n  // need to process.\n  self.effectiveLocalPackageDirs = [];\n\n  // A WatchSet that detects when the set of packages and their locations\n  // changes. ie, the listings of 'packages' directories, and the contents of\n  // package.js files underneath.  It does NOT track the rest of the source of\n  // the packages: that wouldn't be helpful to the runner since it would be too\n  // coarse to tell if a change is client-only or not.  (But any change to the\n  // layout of where packages live counts as a non-client-only change.)\n  self.packageLocationWatchSet = new watch.WatchSet;\n\n  self._nextId = 1;\n};\n\n_.extend(LocalCatalog.prototype, {\n  toString: function () {\n    var self = this;\n    return \"LocalCatalog [localPackageSearchDirs=\"\n      + self.localPackageSearchDirs + \"]\";\n  },\n\n  // Initialize the Catalog. This must be called before any other\n  // Catalog function.\n\n  // options:\n  //  - localPackageSearchDirs: an array of paths on local disk, that contain\n  //    subdirectories, that each contain a source tree for a package that\n  //    should override the packages on the package server. For example, if\n  //    there is a package 'foo' that we find through localPackageSearchDirs,\n  //    then we will ignore all versions of 'foo' that we find through the\n  //    package server. Directories that don't exist (or paths that aren't\n  //    directories) will be silently ignored.\n  //  - explicitlyAddedLocalPackageDirs: an array of paths which THEMSELVES\n  //    are package source trees.  Takes precedence over packages found\n  //    via localPackageSearchDirs.\n  //  - buildingIsopackets: true if we are building isopackets\n  initialize: function (options) {\n    var self = this;\n    buildmessage.assertInCapture();\n\n    options = options || {};\n\n    self.localPackageSearchDirs = _.map(\n      options.localPackageSearchDirs, function (p) {\n        return files.pathResolve(p);\n      });\n    self.explicitlyAddedLocalPackageDirs = _.map(\n      options.explicitlyAddedLocalPackageDirs, function (p) {\n        return files.pathResolve(p);\n      });\n\n    self._computeEffectiveLocalPackages();\n    self._loadLocalPackages(options.buildingIsopackets);\n    self.initialized = true;\n  },\n\n  // Throw if the catalog's self.initialized value has not been set to true.\n  _requireInitialized: function () {\n    var self = this;\n\n    if (! self.initialized)\n      throw new Error(\"catalog not initialized yet?\");\n  },\n\n  // Return an array with the names of all of the packages that we know about,\n  // in no particular order.\n  getAllPackageNames: function (options) {\n    var self = this;\n    self._requireInitialized();\n\n    return _.keys(self.packages);\n  },\n\n  // Return an array with the names of all of the non-test packages that we know\n  // about, in no particular order.\n  getAllNonTestPackageNames: function (options) {\n    var self = this;\n    self._requireInitialized();\n\n    var ret = [];\n    _.each(self.packages, function (record, name) {\n      record.versionRecord.isTest || ret.push(name);\n    });\n    return ret;\n  },\n\n  // Returns general (non-version-specific) information about a\n  // package, or null if there is no such package.\n  getPackage: function (name, options) {\n    var self = this;\n    self._requireInitialized();\n    options = options || {};\n\n    if (!_.has(self.packages, name))\n      return null;\n    return self.packages[name].packageRecord;\n  },\n\n  // Given a package, returns an array of the versions available (ie, the one\n  // version we have, or an empty array).\n  getSortedVersions: function (name) {\n    var self = this;\n    self._requireInitialized();\n\n    if (!_.has(self.packages, name))\n      return [];\n    return [self.packages[name].versionRecord.version];\n  },\n\n  // Given a package, returns an array of the version records available (ie, the\n  // one version we have, or an empty array). This method is intended for use by\n  // Version Solver's CatalogLoader.\n  //\n  // As a special case, if name is an isobuild:* pseudo-package, returns\n  // (minimal) information about it as well.\n  getSortedVersionRecords: function (name) {\n    var self = this;\n    self._requireInitialized();\n\n    if (_.has(KNOWN_ISOBUILD_FEATURE_PACKAGES, name)) {\n      return KNOWN_ISOBUILD_FEATURE_PACKAGES[name].map(\n        version => ({version, packageName: name, dependencies: {}})\n      );\n    }\n\n    if (!_.has(self.packages, name))\n      return [];\n    return [self.packages[name].versionRecord];\n  },\n\n  // Return information about a particular version of a package, or\n  // null if there is no such package or version.\n  getVersion: function (name, version) {\n    var self = this;\n    self._requireInitialized();\n\n    if (!_.has(self.packages, name))\n      return null;\n    var versionRecord = self.packages[name].versionRecord;\n    if (versionRecord.version !== version)\n      return null;\n    return versionRecord;\n  },\n\n  // As getVersion, but returns info on the latest version of the\n  // package, or null if the package doesn't exist or has no versions.\n  getLatestVersion: function (name) {\n    var self = this;\n\n    if (!_.has(self.packages, name))\n      return null;\n    return self.packages[name].versionRecord;\n  },\n\n  getVersionBySourceRoot: function (sourceRoot) {\n    var self = this;\n    var packageObj = _.find(self.packages, function (p) {\n      return p.packageSource.sourceRoot === sourceRoot;\n    });\n    if (! packageObj)\n      return null;\n    return packageObj.versionRecord;\n  },\n\n  // Compute self.effectiveLocalPackageDirs from self.localPackageSearchDirs and\n  // self.explicitlyAddedLocalPackageDirs.\n  _computeEffectiveLocalPackages: function () {\n    var self = this;\n    buildmessage.assertInCapture();\n\n    self.effectiveLocalPackageDirs = [];\n\n    buildmessage.enterJob(\"looking for packages\", function () {\n      _.each(self.explicitlyAddedLocalPackageDirs, function (explicitDir) {\n        var packageJs = watch.readAndWatchFile(\n          self.packageLocationWatchSet,\n          files.pathJoin(explicitDir, 'package.js'));\n        // We asked specifically for this directory, but it has no package!\n        if (packageJs === null) {\n          buildmessage.error(\"package has no package.js file\", {\n            file: explicitDir\n          });\n          return;  // recover by ignoring\n        }\n        self.effectiveLocalPackageDirs.push(explicitDir);\n      });\n\n      _.each(self.localPackageSearchDirs, function (searchDir) {\n        var possiblePackageDirs = watch.readAndWatchDirectory(\n          self.packageLocationWatchSet, {\n            absPath: searchDir,\n            include: [/\\/$/]\n          });\n        // Not a directory? Ignore.\n        if (possiblePackageDirs === null)\n          return;\n\n        _.each(possiblePackageDirs, function (subdir) {\n          // readAndWatchDirectory adds a slash to the end of directory names to\n          // differentiate them from filenames. Remove it.\n          subdir = subdir.substr(0, subdir.length - 1);\n          var absPackageDir = files.pathJoin(searchDir, subdir);\n\n          // Consider a directory to be a package source tree if it contains\n          // 'package.js'. (We used to support isopacks in\n          // localPackageSearchDirs, but no longer.)\n          var packageJs = watch.readAndWatchFile(\n            self.packageLocationWatchSet,\n            files.pathJoin(absPackageDir, 'package.js'));\n          if (packageJs !== null) {\n            // Let earlier package directories override later package\n            // directories.\n\n            // We don't know the name of the package, so we can't deal with\n            // duplicates yet. We are going to have to rely on the fact that we\n            // are putting these in in order, to be processed in order.\n            self.effectiveLocalPackageDirs.push(absPackageDir);\n          }\n        });\n      });\n    });\n  },\n\n  _loadLocalPackages: function (buildingIsopackets) {\n    var self = this;\n    buildmessage.assertInCapture();\n\n    // Load the package source from a directory. We don't know the names of our\n    // local packages until we do this.\n    //\n    // THIS MUST BE RUN IN LOAD ORDER. Let's say that we have two directories\n    // for mongo-livedata. The first one processed by this function will be\n    // canonical.  The second one will be ignored.\n    //\n    // (note: this is the behavior that we want for overriding things in\n    //  checkout.  It is not clear that you get good UX if you have two packages\n    //  with the same name in your app. We don't check that.)\n    var initSourceFromDir = function (packageDir, definiteName) {\n      var packageSource = new PackageSource;\n      buildmessage.enterJob({\n        title: \"reading package from `\" + packageDir + \"`\",\n        rootPath: packageDir\n      }, function () {\n        var initFromPackageDirOptions = {\n          buildingIsopackets: !! buildingIsopackets\n        };\n        // If we specified a name, then we know what we want to get and should\n        // pass that into the options. Otherwise, we will use the 'name'\n        // attribute from package-source.js.\n        if (definiteName) {\n          initFromPackageDirOptions.name = definiteName;\n        }\n        packageSource.initFromPackageDir(packageDir, initFromPackageDirOptions);\n        if (buildmessage.jobHasMessages())\n          return;  // recover by ignoring\n\n        // Now that we have initialized the package from package.js, we know its\n        // name.\n        var name = packageSource.name;\n\n        // We should only have one package dir for each name; in this case, we\n        // are going to take the first one we get (since we preserved the order\n        // in which we loaded local package dirs when running this function.)\n        if (_.has(self.packages, name))\n          return;\n\n        self.packages[name] = {\n          packageSource: packageSource,\n          packageRecord: {\n            _id: \"PID\" + self._nextId++,\n            name: name,\n            maintainers: null,\n            lastUpdated: null\n          },\n          versionRecord: {\n            _id: \"VID\" + self._nextId++,\n            packageName: name,\n            testName: packageSource.testName,\n            version: packageSource.version,\n            publishedBy: null,\n            description: packageSource.metadata.summary,\n            git: packageSource.metadata.git,\n            dependencies: packageSource.getDependencyMetadata(),\n            source: null,\n            lastUpdated: null,\n            published: null,\n            isTest: packageSource.isTest,\n            debugOnly: packageSource.debugOnly,\n            prodOnly: packageSource.prodOnly,\n            containsPlugins: packageSource.containsPlugins()\n          }\n        };\n\n        // If this is NOT a test package AND it has tests (tests will be\n        // marked as test packages by package source, so we will not recurse\n        // infinitely), then process that too.\n        if (!packageSource.isTest && packageSource.testName) {\n          initSourceFromDir(packageSource.sourceRoot, packageSource.testName);\n        }\n      });\n    };\n\n    // Load the package sources for packages and their tests into\n    // self.packages.\n    //\n    // XXX We should make this work with parallel: true; right now it seems to\n    // hit node problems.\n    buildmessage.forkJoin(\n      { 'title': 'initializing packages', parallel: false },\n      self.effectiveLocalPackageDirs,\n      function (dir) {\n        initSourceFromDir(dir);\n      });\n  },\n\n  getPackageSource: function (name) {\n    var self = this;\n    if (! _.has(self.packages, name))\n      return null;\n    return self.packages[name].packageSource;\n  }\n});\n\nexports.LocalCatalog = LocalCatalog;\n"]}