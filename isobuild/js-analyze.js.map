{"version":3,"sources":["/tools/isobuild/js-analyze.js"],"names":[],"mappings":";;;2BAAsB,cAAc;;sBACI,QAAQ;;;AAGhD,SAAS,UAAU,CAAC,MAAM,EAAE;AAC1B,MAAI;AACF,WAAO,mBAAM,MAAM,EAAE,EAAC,UAAU,EAAE,KAAK,EAAC,CAAC,CAAC;GAC3C,CAAC,OAAO,CAAC,EAAE;AACV,QAAI,OAAO,CAAC,CAAC,GAAG,KAAK,QAAQ,EAAE;AAC7B,OAAC,CAAC,WAAW,GAAG,IAAI,CAAC;KACtB;AACD,UAAM,CAAC,CAAC;GACT;CACF;;;;;;;;;;;;;AAYM,SAAS,mBAAmB,CAAC,MAAM,EAAE;;;AAG1C,MAAM,aAAa,GAAG,sBAAsB,GAAG,MAAM,GAAG,YAAY,CAAC;;AAErE,MAAM,GAAG,GAAG,UAAU,CAAC,aAAa,CAAC,CAAC;;;;;;;;;;;;;;;AAetC,MAAM,YAAY,GAAG,gBAAa,GAAG,EAAE,EAAE,UAAU,EAAE,IAAI,EAAE,CAAC,CAAC;AAC7D,MAAM,WAAW,GAAG,YAAY,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;;AAE9C,MAAM,eAAe,GAAG,EAAE,CAAC;;AAE3B,aAAW,CAAC,QAAQ,CAAC,SAAS,CAAC,OAAO,CAAC,UAAC,QAAQ,EAAK;AACnD,mBAAe,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,IAAI,CAAC;GACvC,CAAC,CAAC;;AAEH,SAAO,eAAe,CAAC;CACxB","file":"tools/isobuild/js-analyze.js.map","sourcesContent":["import { parse } from 'meteor-babel';\nimport { analyze as analyzeScope } from 'escope';\n\n// Like babel.parse, but annotates any thrown error with $ParseError = true.\nfunction tryToParse(source) {\n  try {\n    return parse(source, {strictMode: false});\n  } catch (e) {\n    if (typeof e.loc === 'object') {\n      e.$ParseError = true;\n    }\n    throw e;\n  }\n}\n\n// Analyze the JavaScript source code `source` and return a dictionary of all\n// globals which are assigned to in the package. The values in the dictionary\n// are all `true`.\n//\n// This is intended for use in detecting package-scope variables in Meteor\n// packages, where the linker needs to add a \"var\" statement to prevent them\n// from staying as globals.\n//\n// It only cares about assignments to variables; an assignment to a field on an\n// object (`Foo.Bar = true`) neither causes `Foo` nor `Foo.Bar` to be returned.\nexport function findAssignedGlobals(source) {\n  // escope's analyzer treats vars in the top-level \"Program\" node as globals.\n  // The \\n// */\\n is necessary in case source ends with an unclosed comment.\n  const wrappedSource = 'function wrapper() {' + source + '\\n// */\\n}';\n\n  const ast = tryToParse(wrappedSource);\n  // We have to pass ignoreEval; otherwise, the existence of a direct eval call\n  // causes escope to not bother to resolve references in the eval's scope.\n  // This is because an eval can pull references inward:\n  //\n  //   function outer() {\n  //     var i = 42;\n  //     function inner() {\n  //       eval('var i = 0');\n  //       i;  // 0, not 42\n  //     }\n  //   }\n  //\n  // But it can't pull references outward, so for our purposes it is safe to\n  // ignore.\n  const scopeManager = analyzeScope(ast, { ignoreEval: true });\n  const globalScope = scopeManager.acquire(ast);\n\n  const assignedGlobals = {};\n  // Underscore is not available in this package.\n  globalScope.implicit.variables.forEach((variable) => {\n    assignedGlobals[variable.name] = true;\n  });\n\n  return assignedGlobals;\n}\n"]}