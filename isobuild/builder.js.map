{"version":3,"sources":["/tools/isobuild/builder.js"],"names":[],"mappings":"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","file":"tools/isobuild/builder.js.map","sourcesContent":["import {WatchSet, readAndWatchFile, sha1} from '../fs/watch.js';\nimport files from '../fs/files.js';\nimport NpmDiscards from './npm-discards.js';\nimport {Profile} from '../tool-env/profile.js';\n\n// Builder has two modes of working:\n// - write files to a temp directory and later atomically move it to destination\n// - write files in-place replacing the older files\n// The later doesn't work on Windows but works well on Mac OS X and Linux, since\n// the file system allows writing new files to the path of a file opened by a\n// process. The process only retains the inode, not the path.\nconst ENABLE_IN_PLACE_BUILDER_REPLACEMENT =\n  (process.platform !== 'win32') &&\n  ! process.env.METEOR_DISABLE_BUILDER_IN_PLACE;\n\n\n// Builder encapsulates much of the file-handling logic need to create\n// \"bundles\" (directory trees such as site archives, programs, or\n// packages). It can create a temporary directory in which to build\n// the bundle, moving the bundle atomically into place when and if the\n// build successfully completes; sanitize and generate unique\n// filenames; and track dependencies (files that should be watched for\n// changes when developing interactively).\n//\n// Options:\n//  - outputPath: Required. Path to the directory that will hold the\n//    bundle when building is complete. It should not exist. Its\n//    parents will be created if necessary.\n// - previousBuilder: Optional. An in-memory instance of Builder left\n// from the previous iteration. It is assumed that the previous builder\n// has completed its job successfully and its files are stored on the\n// file system in the exact layout as described in its usedAsFile data\n// structure; and the hashes of the contents correspond to the\n// writtenHashes data strcture.\nexport default class Builder {\n  constructor({outputPath, previousBuilder}) {\n    this.outputPath = outputPath;\n\n    // Paths already written to. Map from canonicalized relPath (no\n    // trailing slash) to true for a file, or false for a directory.\n    this.usedAsFile = { '': false, '.': false };\n    this.previousUsedAsFile = {};\n\n    this.writtenHashes = {};\n    this.previousWrittenHashes = {};\n\n    // foo/bar => foo/.build1234.bar\n    // Should we include a random number? The advantage is that multiple\n    // builds can run in parallel. The disadvantage is that stale build\n    // files hang around forever. For now, go with the former.\n    const nonce = Math.floor(Math.random() * 999999);\n    this.buildPath = files.pathJoin(files.pathDirname(this.outputPath),\n                                    '.build' + nonce + \".\" +\n                                    files.pathBasename(this.outputPath));\n\n    let resetBuildPath = true;\n\n    // If we have a previous builder and we are allowed to re-use it,\n    // let's keep all the older files on the file-system and replace\n    // only outdated ones + write the new files in the same path\n    if (previousBuilder && ENABLE_IN_PLACE_BUILDER_REPLACEMENT) {\n      if (previousBuilder.outputPath !== outputPath) {\n        throw new Error(\n          `previousBuilder option can only be set to a builder with the same output path.\nPrevious builder: ${previousBuilder.outputPath}, this builder: ${outputPath}`\n        );\n      }\n\n      if (files.exists(previousBuilder.outputPath)) {\n        // write files in-place in the output directory of the previous builder\n        this.buildPath = previousBuilder.outputPath;\n\n        this.previousWrittenHashes = previousBuilder.writtenHashes;\n        this.previousUsedAsFile = previousBuilder.usedAsFile;\n\n        resetBuildPath = false;\n      } else {\n        resetBuildPath = true;\n      }\n    }\n\n    // Build the output from scratch\n    if (resetBuildPath) {\n      files.rm_recursive(this.buildPath);\n      files.mkdir_p(this.buildPath, 0o755);\n    }\n\n    this.watchSet = new WatchSet();\n\n    // XXX cleaner error handling. don't make the humans read an\n    // exception (and, make suitable for use in automated systems)\n  }\n\n  // Like mkdir_p, but records in self.usedAsFile that we have created\n  // the directories, and takes a path relative to the bundle\n  // root. Throws an exception on failure.\n  _ensureDirectory(relPath) {\n    const parts = files.pathNormalize(relPath).split(files.pathSep);\n    if (parts.length > 1 && parts[parts.length - 1] === '')\n      parts.pop(); // remove trailing slash\n\n    const partsSoFar = [];\n    parts.forEach(part => {\n      partsSoFar.push(part);\n      const partial = partsSoFar.join(files.pathSep);\n      if (! (partial in this.usedAsFile)) {\n        let needToMkdir = true;\n        if (partial in this.previousUsedAsFile) {\n          if (this.previousUsedAsFile[partial]) {\n            // was previously used as file, delete it, create a directory\n            files.unlink(partial);\n          } else {\n            // is already a directory\n            needToMkdir = false;\n          }\n        }\n\n        if (needToMkdir) {\n          // It's new -- create it\n          files.mkdir(files.pathJoin(this.buildPath, partial), 0o755);\n        }\n        this.usedAsFile[partial] = false;\n      } else if (this.usedAsFile[partial]) {\n        // Already exists and is a file. Oops.\n        throw new Error(`tried to make ${relPath} a directory but ${partial} is already a file`);\n      } else {\n        // Already exists and is a directory\n      }\n    });\n  }\n\n  // isDirectory defaults to false\n  _sanitize(relPath, isDirectory) {\n    const parts = relPath.split(files.pathSep);\n    const partsOut = [];\n    for (let i = 0; i < parts.length; i++) {\n      let part = parts[i];\n      const shouldBeFile = (i === parts.length - 1) && ! isDirectory;\n      const mustBeUnique = (i === parts.length - 1);\n\n      // Basic sanitization\n      if (part.match(/^\\.+$/))\n        throw new Error(`Path contains forbidden segment '${part}'`);\n\n      part = part.replace(/[^a-zA-Z0-9._\\:-]/g, '');\n\n      // If at last component, pull extension (if any) off of part\n      let ext = '';\n      if (shouldBeFile) {\n        const split = part.split('.');\n        if (split.length > 1)\n          ext = \".\" + split.pop();\n        part = split.join('.');\n      }\n\n      // Make sure it's sufficiently unique\n      let suffix = '';\n      while (true) {\n        const candidate = files.pathJoin(partsOut.join(files.pathSep), part + suffix + ext);\n        if (candidate.length) {\n          // If we've never heard of this, then it's unique enough.\n          if (!(candidate in this.usedAsFile))\n            break;\n          // If we want this bit to be a directory, and we don't need it to be\n          // unique (ie, it isn't the very last bit), and it's currently a\n          // directory, then that's OK.\n          if (!(mustBeUnique || this.usedAsFile[candidate]))\n            break;\n          // OK, either we want it to be unique and it already exists; or it is\n          // currently a file (and we want it to be either a different file or a\n          // directory).  Try a new suffix.\n        }\n\n        suffix++; // first increment will do '' -> 1\n      }\n\n      partsOut.push(part + suffix + ext);\n    }\n\n    return partsOut.join(files.pathSep);\n  }\n\n  // Write either a buffer or the contents of a file to `relPath` (a\n  // path to a file relative to the bundle root), creating it (and any\n  // enclosing directories) if it doesn't exist yet. Exactly one of\n  // `data` and or `file` must be passed.\n  //\n  // Options:\n  // - data: a Buffer to write to relPath. Overrides `file`.\n  // - file: a filename to write to relPath, as a string.\n  // - sanitize: if true, then all components of the path are stripped\n  //   of any potentially troubling characters, an exception is thrown\n  //   if any path segments consist entirely of dots (eg, '..'), and\n  //   if there is a file in the bundle with the same relPath, then\n  //   the path is changed by adding a numeric suffix.\n  // - hash: a sha1 string used to determine if the contents of the\n  //   new file written is not cached.\n  // - executable: if true, mark the file as executable.\n  // - symlink: if set to a string, create a symlink to its value\n  //\n  // Returns the final canonicalize relPath that was written to.\n  //\n  // If `file` is used then it will be added to the builder's WatchSet.\n  write(relPath, {data, file, hash, sanitize, executable, symlink}) {\n    // Ensure no trailing slash\n    if (relPath.slice(-1) === files.pathSep)\n      relPath = relPath.slice(0, -1);\n\n    // In sanitize mode, ensure path does not contain segments like\n    // '..', does not contain forbidden characters, and is unique.\n    if (sanitize)\n      relPath = this._sanitize(relPath);\n\n    let getData = null;\n    if (data) {\n      if (! (data instanceof Buffer))\n        throw new Error(\"data must be a Buffer\");\n      if (file)\n        throw new Error(\"May only pass one of data and file, not both\");\n      getData = () => data;\n    } else if (file) {\n      // postpone reading the file into memory\n      getData = () => readAndWatchFile(this.watchSet, files.pathResolve(file));\n    } else if (! symlink) {\n      throw new Error('Builder can not write without either data or a file path or a symlink path: ' + relPath);\n    }\n\n    this._ensureDirectory(files.pathDirname(relPath));\n    const absPath = files.pathJoin(this.buildPath, relPath);\n\n    if (symlink) {\n      files.symlink(symlink, absPath);\n    } else {\n      hash = hash || sha1(getData());\n\n      if (this.previousWrittenHashes[relPath] !== hash) {\n        // Builder is used to create build products, which should be read-only;\n        // users shouldn't be manually editing automatically generated files and\n        // expecting the results to \"stick\".\n        atomicallyRewriteFile(absPath, getData(), {\n          mode: executable ? 0o555 : 0o444\n        });\n      }\n\n      this.writtenHashes[relPath] = hash;\n    }\n    this.usedAsFile[relPath] = true;\n\n    return relPath;\n  }\n\n  // Serialize `data` as JSON and write it to `relPath` (a path to a\n  // file relative to the bundle root), creating parent directories as\n  // necessary. Throw an exception if the file already exists.\n  writeJson(relPath, data) {\n    // Ensure no trailing slash\n    if (relPath.slice(-1) === files.pathSep)\n      relPath = relPath.slice(0, -1);\n\n    this._ensureDirectory(files.pathDirname(relPath));\n    const absPath = files.pathJoin(this.buildPath, relPath);\n\n    atomicallyRewriteFile(\n      absPath,\n      new Buffer(JSON.stringify(data, null, 2), 'utf8'),\n      {mode: 0o444});\n\n    this.usedAsFile[relPath] = true;\n  }\n\n  // Add relPath to the list of \"already taken\" paths in the\n  // bundle. This will cause write, when in sanitize mode, to never\n  // pick this filename (and will prevent files that from being\n  // written that would conflict with paths that we are expecting to\n  // be directories). Calling this twice on the same relPath will\n  // given an exception.\n  //\n  // Returns the *current* (temporary!) path to where the file or directory\n  // lives. This is so you could use non-builder code to write into a reserved\n  // directory.\n  //\n  // options:\n  // - directory: set to true to reserve this relPath to be a\n  //   directory rather than a file.\n  reserve(relPath, {directory} = {}) {\n    // Ensure no trailing slash\n    if (relPath.slice(-1) === files.pathSep)\n      relPath = relPath.slice(0, -1);\n\n    const parts = relPath.split(files.pathSep);\n    const partsSoFar = [];\n    for (let i = 0; i < parts.length; i ++) {\n      const part = parts[i];\n      partsSoFar.push(part);\n      const soFar = partsSoFar.join(files.pathSep);\n      if (this.usedAsFile[soFar])\n        throw new Error(\"Path reservation conflict: \" + relPath);\n\n      const shouldBeDirectory = (i < parts.length - 1) || directory;\n      if (shouldBeDirectory) {\n        if (! (soFar in this.usedAsFile)) {\n          let needToMkdir = true;\n          if (soFar in this.previousUsedAsFile) {\n            if (this.previousUsedAsFile[soFar]) {\n              files.unlink(soFar);\n            } else {\n              needToMkdir = false;\n            }\n          }\n          if (needToMkdir) {\n            files.mkdir(files.pathJoin(this.buildPath, soFar), 0o755);\n          }\n          this.usedAsFile[soFar] = false;\n        }\n      } else {\n        this.usedAsFile[soFar] = true;\n      }\n    }\n\n    // Return the path we reserved.\n    return files.pathJoin(this.buildPath, relPath);\n  }\n\n  // Generate and reserve a unique name for a file based on `relPath`,\n  // and return it. If `relPath` is available (there is no file with\n  // that name currently existing or reserved, it doesn't contain\n  // forbidden characters, a prefix of it is not already in use as a\n  // file rather than a directory) then the return value will be\n  // `relPath`. Otherwise relPath will be modified to get the return\n  // value, say by adding a numeric suffix to some path components\n  // (preserving the file extension however) and deleting forbidden\n  // characters. Throws an exception if relPath contains any segments\n  // that are all dots (eg, '..').\n  //\n  // options:\n  //\n  // - directory: generate (and reserve) a name for a directory,\n  //   rather than a file.\n  generateFilename(relPath, {directory} = {}) {\n    relPath = this._sanitize(relPath, directory);\n    this.reserve(relPath, { directory });\n    return relPath;\n  }\n\n  // Convenience wrapper around generateFilename and write.\n  //\n  // (Note that in the object returned by builder.enter, this method\n  // is patched through directly rather than rewriting its inputs and\n  // outputs. This is only valid because it does nothing with its inputs\n  // and outputs other than send pass them to other methods.)\n  writeToGeneratedFilename(relPath, writeOptions) {\n    const generated = this.generateFilename(relPath);\n    this.write(generated, writeOptions);\n    return generated;\n  }\n\n  // Recursively copy a directory and all of its contents into the\n  // bundle. But if the symlink option was passed to the Builder\n  // constructor, then make a symlink instead, if possible.\n  //\n  // Unlike with files.cp_r, if a symlink is found, it is copied as a symlink.\n  //\n  // This does NOT add anything to the WatchSet.\n  //\n  // Options:\n  // - from: source path on local disk to copy from\n  // - to: relative path to a directory in the bundle that will\n  //   receive the files\n  // - ignore: array of regexps of filenames (that is, basenames) to\n  //   ignore (they may still be visible in the output bundle if\n  //   symlinks are being used).  Like with WatchSets, they match against\n  //   entries that end with a slash if it's a directory.\n  // - specificFiles: just copy these paths (specified as relative to 'to').\n  // - symlink: true if the directory should be symlinked instead of copying\n  copyDirectory({from, to, ignore, specificFiles, symlink, npmDiscards}) {\n    if (to.slice(-1) === files.pathSep)\n      to = to.slice(0, -1);\n\n    const absPathTo = files.pathJoin(this.buildPath, to);\n    if (symlink) {\n      if (specificFiles) {\n        throw new Error(\"can't copy only specific paths with a single symlink\");\n      }\n\n      if (this.usedAsFile[to]) {\n        throw new Error(\"tried to copy a directory onto \" + to +\n                        \" but it is is already a file\");\n      }\n\n      let canSymlink = true;\n      // Symlinks don't work exactly the same way on Windows, and furthermore\n      // they request Admin permissions to set.\n      if (process.platform === 'win32') {\n        canSymlink = false;\n      } else if (to in this.usedAsFile) {\n        // It's already here and is a directory, maybe because of a call to\n        // reserve with {directory: true}. If it's an empty directory, this is\n        // salvageable. The directory should exist, because all code paths which\n        // set usedAsFile to false create the directory.\n        //\n        // XXX This is somewhat broken: what if the reason we're in\n        // self.usedAsFile is because an immediate child of ours was reserved as\n        // a file but not actually written yet?\n        const children = files.readdir(absPathTo);\n        if (Object.keys(children).length === 0) {\n          files.rmdir(absPathTo);\n        } else {\n          canSymlink = false;\n        }\n      }\n\n      if (canSymlink) {\n        this._ensureDirectory(files.pathDirname(to));\n        files.symlink(files.pathResolve(from), absPathTo);\n        return;\n      }\n    }\n\n    ignore = ignore || [];\n    let specificPaths = null;\n    if (specificFiles) {\n      specificPaths = {};\n      specificFiles.forEach(f => {\n        while (f !== '.') {\n          specificPaths[files.pathJoin(to, f)] = true;\n          f = files.pathDirname(f);\n        }\n      });\n    }\n\n    let walk = (absFrom, relTo) => {\n      this._ensureDirectory(relTo);\n\n      files.readdir(absFrom).forEach(item => {\n        const thisAbsFrom = files.pathResolve(absFrom, item);\n        const thisRelTo = files.pathJoin(relTo, item);\n\n        if (specificPaths && !(thisRelTo in specificPaths)) {\n          return;\n        }\n\n        const fileStatus = files.lstat(thisAbsFrom);\n\n        let itemForMatch = item;\n        const isDirectory = fileStatus.isDirectory();\n        if (isDirectory) {\n          itemForMatch += '/';\n        }\n\n        // skip excluded files\n        if (ignore.some(pattern => itemForMatch.match(pattern))) return;\n\n        if (npmDiscards instanceof NpmDiscards &&\n            npmDiscards.shouldDiscard(thisAbsFrom, isDirectory)) {\n          return;\n        }\n\n        if (isDirectory) {\n          walk(thisAbsFrom, thisRelTo);\n        } else if (fileStatus.isSymbolicLink()) {\n          files.symlink(files.readlink(thisAbsFrom),\n                         files.pathResolve(this.buildPath, thisRelTo));\n          // A symlink counts as a file, as far as \"can you put something under\n          // it\" goes.\n          this.usedAsFile[thisRelTo] = true;\n        } else {\n          // XXX can't really optimize this copying without reading\n          // the file into memory to calculate the hash.\n          files.copyFile(thisAbsFrom,\n                         files.pathResolve(this.buildPath, thisRelTo),\n                         fileStatus.mode);\n          this.usedAsFile[thisRelTo] = true;\n        }\n      });\n    };\n\n    walk(from, to);\n  }\n\n  // Returns a new Builder-compatible object that works just like a\n  // Builder, but interprets all paths relative to 'relPath', a path\n  // relative to the bundle root which should not start with a '/'.\n  //\n  // The sub-builder returned does not have all Builder methods (for\n  // example, complete() wouldn't make sense) and you should not rely\n  // on it being instanceof Builder.\n  enter(relPath) {\n    const methods = [\"write\", \"writeJson\", \"reserve\", \"generateFilename\",\n                   \"copyDirectory\", \"enter\"];\n    const subBuilder = {};\n    const relPathWithSep = relPath + files.pathSep;\n\n    methods.forEach(method => {\n      subBuilder[method] = (...args) => {\n        if (method !== \"copyDirectory\") {\n          // Normal method (relPath as first argument)\n          args[0] = files.pathJoin(relPath, args[0]);\n        } else {\n          // with copyDirectory the path we have to fix up is inside\n          // an options hash\n          args[0].to = files.pathJoin(relPath, args[0].to);\n        }\n\n        let ret = this[method](...args);\n\n        if (method === \"generateFilename\") {\n          // fix up the returned path to be relative to the\n          // sub-bundle, not the parent bundle\n          if (ret.substr(0, 1) === '/')\n            ret = ret.substr(1);\n          if (ret.substr(0, relPathWithSep.length) !== relPathWithSep)\n            throw new Error(\"generateFilename returned path outside of \" +\n                            \"sub-bundle?\");\n          ret = ret.substr(relPathWithSep.length);\n        }\n\n        return ret;\n      };\n    });\n\n    // Methods that don't have to fix up arguments or return values, because\n    // they are implemented purely in terms of other methods which do.\n    const passThroughMethods = [\"writeToGeneratedFilename\"];\n    passThroughMethods.forEach(method => {\n      subBuilder[method] = this[method];\n    });\n\n    return subBuilder;\n  }\n\n  // Move the completed bundle into its final location (outputPath)\n  complete() {\n    if (this.previousUsedAsFile) {\n      // delete files and folders left-over from previous runs and not\n      // re-used in this run\n      const removed = {};\n      const paths = Object.keys(this.previousUsedAsFile);\n      paths.forEach((path) => {\n        // if the same path was re-used, leave it\n        if (this.usedAsFile.hasOwnProperty(path)) { return; }\n\n        // otherwise, remove it as it is no longer needed\n\n        // skip if already deleted\n        if (removed.hasOwnProperty(path)) { return; }\n\n        const absPath = files.pathJoin(this.buildPath, path);\n        if (this.previousUsedAsFile[path]) {\n          // file\n          files.unlink(absPath);\n          removed[path] = true;\n        } else {\n          // directory\n          files.rm_recursive(absPath);\n\n          // mark all sub-paths as removed, too\n          paths.forEach((anotherPath) => {\n            if (anotherPath.startsWith(path + '/')) {\n              removed[anotherPath] = true;\n            }\n          });\n        }\n      });\n    }\n\n    // XXX Alternatively, we could just keep buildPath around, and make\n    // outputPath be a symlink pointing to it. This doesn't work for the NPM use\n    // case of renameDirAlmostAtomically since that one is constructing files to\n    // be checked in to version control, but here we could get away with it.\n    if (this.buildPath !== this.outputPath) {\n      files.renameDirAlmostAtomically(this.buildPath, this.outputPath);\n    }\n  }\n\n  // Delete the partially-completed bundle. Do not disturb outputPath.\n  abort() {\n    files.rm_recursive(this.buildPath);\n  }\n\n  // Returns a WatchSet representing all files that were read from disk by the\n  // builder.\n  getWatchSet() {\n    return this.watchSet;\n  }\n}\n\nfunction atomicallyRewriteFile(path, data, options) {\n  let stat = null;\n  try {\n    stat = files.stat(path);\n  } catch (e) {\n    if (e.code !== 'ENOENT') {\n      throw e;\n    }\n  }\n\n  if (stat && stat.isDirectory()) {\n    files.rm_recursive(path);\n    files.writeFile(path, data, options);\n  } else {\n    // create a different file with a random name and then rename over atomically\n    const rname = '.builder-tmp-file.' + Math.floor(Math.random() * 999999);\n    const rpath = files.pathJoin(files.pathDirname(path), rname);\n    files.writeFile(rpath, data, options);\n    files.rename(rpath, path);\n  }\n}\n\n// Wrap slow methods into Profiler calls\nconst slowBuilderMethods = [\n  '_ensureDirectory', 'write', 'enter', 'copyDirectory', 'enter', 'complete'\n];\n\nslowBuilderMethods.forEach(method => {\n  Builder.prototype[method] =\n    Profile(`Builder#${method}`, Builder.prototype[method]);\n});\n"]}