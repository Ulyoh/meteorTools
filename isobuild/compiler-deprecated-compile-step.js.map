{"version":3,"sources":["/tools/isobuild/compiler-deprecated-compile-step.js"],"names":[],"mappings":"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","file":"tools/isobuild/compiler-deprecated-compile-step.js.map","sourcesContent":["// This file contains an old definition of CompileStep, an object that is passed\n// to the package-provided file handler.\n// Since then, the newer API called \"Batch Plugins\" have replaced it but we keep\n// the functionality for the backwards-compitability.\n// @deprecated\n// XXX COMPAT WITH 1.1.0.2\n\nvar _ = require('underscore');\n\nvar archinfo = require('../utils/archinfo.js');\nvar buildmessage = require('../utils/buildmessage.js');\nvar files = require('../fs/files.js');\nvar colonConverter = require('../utils/colon-converter.js');\nvar watch = require('../fs/watch.js');\n\nvar convertSourceMapPaths = function (sourcemap, f) {\n  if (! sourcemap) {\n    // Don't try to convert it if it doesn't exist\n    return sourcemap;\n  }\n\n  var srcmap = JSON.parse(sourcemap);\n  srcmap.sources = _.map(srcmap.sources, f);\n  return JSON.stringify(srcmap);\n};\n\nexports.makeCompileStep = function (sourceItem, file, inputSourceArch, options) {\n  var resources = options.resources;\n  var addAsset = options.addAsset;\n\n  var relPath = sourceItem.relPath;\n  var fileOptions = _.clone(sourceItem.fileOptions) || {};\n  var absPath = files.pathResolve(inputSourceArch.pkg.sourceRoot, relPath);\n  var filename = files.pathBasename(relPath);\n  var hash = file.hash;\n  var contents = file.contents;\n\n  // This object is called a #CompileStep and it's the interface\n  // to plugins that define new source file handlers (eg,\n  // Coffeescript).\n  //\n  // Fields on CompileStep:\n  //\n  // - arch: the architecture for which we are building\n  // - inputSize: total number of bytes in the input file\n  // - inputPath: the filename and (relative) path of the input\n  //   file, eg, \"foo.js\". We don't provide a way to get the full\n  //   path because you're not supposed to read the file directly\n  //   off of disk. Instead you should call read(). That way we\n  //   can ensure that the version of the file that you use is\n  //   exactly the one that is recorded in the dependency\n  //   information.\n  // - pathForSourceMap: If this file is to be included in a source map,\n  //   this is the name you should use for it in the map.\n  // - rootOutputPath: on web targets, for resources such as\n  //   stylesheet and static assets, this is the root URL that\n  //   will get prepended to the paths you pick for your output\n  //   files so that you get your own namespace, for example\n  //   '/packages/foo'. null on non-web targets\n  // - fileOptions: any options passed to \"api.addFiles\"; for\n  //   use by the plugin. The built-in \"js\" plugin uses the \"bare\"\n  //   option for files that shouldn't be wrapped in a closure.\n  // - declaredExports: An array of symbols exported by this unibuild, or null\n  //   if it may not export any symbols (eg, test unibuilds). This is used by\n  //   CoffeeScript to ensure that it doesn't close over those symbols, eg.\n  // - read(n): read from the input file. If n is given it should\n  //   be an integer, and you will receive the next n bytes of the\n  //   file as a Buffer. If n is omitted you get the rest of the\n  //   file.\n  // - appendDocument({ section: \"head\", data: \"my markup\" })\n  //   Browser targets only. Add markup to the \"head\" or \"body\"\n  //   Web targets only. Add markup to the \"head\" or \"body\"\n  //   section of the document.\n  // - addStylesheet({ path: \"my/stylesheet.css\", data: \"my css\",\n  //                   sourceMap: \"stringified json sourcemap\"})\n  //   Web targets only. Add a stylesheet to the\n  //   document. 'path' is a requested URL for the stylesheet that\n  //   may or may not ultimately be honored. (Meteor will add\n  //   appropriate tags to cause the stylesheet to be loaded. It\n  //   will be subject to any stylesheet processing stages in\n  //   effect, such as minification.)\n  // - addJavaScript({ path: \"my/program.js\", data: \"my code\",\n  //                   sourcePath: \"src/my/program.js\",\n  //                   bare: true })\n  //   Add JavaScript code, which will be namespaced into this\n  //   package's environment (eg, it will see only the exports of\n  //   this package's imports), and which will be subject to\n  //   minification and so forth. Again, 'path' is merely a hint\n  //   that may or may not be honored. 'sourcePath' is the path\n  //   that will be used in any error messages generated (eg,\n  //   \"foo.js:4:1: syntax error\"). It must be present and should\n  //   be relative to the project root. Typically 'inputPath' will\n  //   do handsomely. \"bare\" means to not wrap the file in\n  //   a closure, so that its vars are shared with other files\n  //   in the module.\n  // - addAsset({ path: \"my/image.png\", data: Buffer })\n  //   Add a file to serve as-is over HTTP (web targets) or\n  //   to include as-is in the bundle (os targets).\n  //   This time `data` is a Buffer rather than a string. For\n  //   web targets, it will be served at the exact path you\n  //   request (concatenated with rootOutputPath). For server\n  //   targets, the file can be retrieved by passing path to\n  //   Assets.getText or Assets.getBinary.\n  // - error({ message: \"There's a problem in your source file\",\n  //           sourcePath: \"src/my/program.ext\", line: 12,\n  //           column: 20, func: \"doStuff\" })\n  //   Flag an error -- at a particular location in a source\n  //   file, if you like (you can even indicate a function name\n  //   to show in the error, like in stack traces). sourcePath,\n  //   line, column, and func are all optional.\n  //\n  // XXX for now, these handlers must only generate portable code\n  // (code that isn't dependent on the arch, other than 'web'\n  // vs 'os') -- they can look at the arch that is provided\n  // but they can't rely on the running on that particular arch\n  // (in the end, an arch-specific unibuild will be emitted only if\n  // there are native node modules). Obviously this should\n  // change. A first step would be a setOutputArch() function\n  // analogous to what we do with native node modules, but maybe\n  // what we want is the ability to ask the plugin ahead of time\n  // how specific it would like to force unibuilds to be.\n  //\n  // XXX we handle encodings in a rather cavalier way and I\n  // suspect we effectively end up assuming utf8. We can do better\n  // than that!\n  //\n  // XXX addAsset probably wants to be able to set MIME type and\n  // also control any manifest field we deem relevant (if any)\n  //\n  // XXX Some handlers process languages that have the concept of\n  // include files. These are problematic because we need to\n  // somehow instrument them to get the names and hashs of all of\n  // the files that they read for dependency tracking purposes. We\n  // don't have an API for that yet, so for now we provide a\n  // workaround, which is that _fullInputPath contains the full\n  // absolute path to the input files, which allows such a plugin\n  // to set up its include search path. It's then on its own for\n  // registering dependencies (for now..)\n  //\n  // XXX in the future we should give plugins an easy and clean\n  // way to return errors (that could go in an overall list of\n  // errors experienced across all files)\n  var readOffset = 0;\n\n  /**\n   * The comments for this class aren't used to generate docs right now.\n   * The docs live in the GitHub Wiki at: https://github.com/meteor/meteor/wiki/CompileStep-API-for-Build-Plugin-Source-Handlers\n   * @class CompileStep\n   * @summary The object passed into Plugin.registerSourceHandler\n   * @global\n   */\n  var compileStep = {\n\n    /**\n     * @summary The total number of bytes in the input file.\n     * @memberOf CompileStep\n     * @instance\n     * @type {Integer}\n     */\n    inputSize: contents.length,\n\n    /**\n     * @summary The filename and relative path of the input file.\n     * Please don't use this filename to read the file from disk, instead\n     * use [compileStep.read](CompileStep-read).\n     * @type {String}\n     * @instance\n     * @memberOf CompileStep\n     */\n    inputPath: files.convertToOSPath(relPath, true),\n\n    /**\n     * @summary The filename and absolute path of the input file.\n     * Please don't use this filename to read the file from disk, instead\n     * use [compileStep.read](CompileStep-read).\n     * @type {String}\n     * @instance\n     * @memberOf CompileStep\n     */\n    fullInputPath: files.convertToOSPath(absPath),\n\n    // The below is used in the less and stylus packages... so it should be\n    // public API.\n    _fullInputPath: files.convertToOSPath(absPath), // avoid, see above..\n\n    // Used for one optimization. Don't rely on this otherwise.\n    _hash: hash,\n\n    // XXX duplicates _pathForSourceMap() in linker\n    /**\n     * @summary If you are generating a sourcemap for the compiled file, use\n     * this path for the original file in the sourcemap.\n     * @type {String}\n     * @memberOf CompileStep\n     * @instance\n     */\n    pathForSourceMap: files.convertToOSPath(\n      inputSourceArch.pkg.name ?  inputSourceArch.pkg.name + \"/\" + relPath :\n                                  files.pathBasename(relPath), true),\n\n    // null if this is an app. intended to be used for the sources\n    // dictionary for source maps.\n    /**\n     * @summary The name of the package in which the file being built exists.\n     * @type {String}\n     * @memberOf CompileStep\n     * @instance\n     */\n    packageName: inputSourceArch.pkg.name,\n\n    /**\n     * @summary On web targets, this will be the root URL prepended\n     * to the paths you pick for your output files. For example,\n     * it could be \"/packages/my-package\".\n     * @type {String}\n     * @memberOf CompileStep\n     * @instance\n     */\n    rootOutputPath: files.convertToOSPath(\n      inputSourceArch.pkg.serveRoot, true),\n\n    /**\n     * @summary The architecture for which we are building. Can be \"os\",\n     * \"web.browser\", or \"web.cordova\".\n     * @type {String}\n     * @memberOf CompileStep\n     * @instance\n     */\n    arch: inputSourceArch.arch,\n\n    /**\n     * @deprecated in 0.9.4\n     * This is a duplicate API of the above, we don't need it.\n     */\n    archMatches: function (pattern) {\n      return archinfo.matches(inputSourceArch.arch, pattern);\n    },\n\n    /**\n     * @summary Any options passed to \"api.addFiles\".\n     * @type {Object}\n     * @memberOf CompileStep\n     * @instance\n     */\n    fileOptions: fileOptions,\n\n    /**\n     * @summary The list of exports that the current package has defined.\n     * Can be used to treat those symbols differently during compilation.\n     * @type {Object}\n     * @memberOf CompileStep\n     * @instance\n     */\n    declaredExports: _.pluck(inputSourceArch.declaredExports, 'name'),\n\n    /**\n     * @summary Read from the input file. If `n` is specified, returns the\n     * next `n` bytes of the file as a Buffer. XXX not sure if this actually\n     * returns a String sometimes...\n     * @param  {Integer} [n] The number of bytes to return.\n     * @instance\n     * @memberOf CompileStep\n     * @returns {Buffer}\n     */\n    read: function (n) {\n      if (n === undefined || readOffset + n > contents.length)\n        n = contents.length - readOffset;\n      var ret = contents.slice(readOffset, readOffset + n);\n      readOffset += n;\n      return ret;\n    },\n\n    /**\n     * @summary Works in web targets only. Add markup to the `head` or `body`\n     * section of the document.\n     * @param  {Object} options\n     * @param {String} options.section Which section of the document should\n     * be appended to. Can only be \"head\" or \"body\".\n     * @param {String} options.data The content to append.\n     * @memberOf CompileStep\n     * @instance\n     */\n    addHtml: function (options) {\n      if (! archinfo.matches(inputSourceArch.arch, \"web\"))\n        throw new Error(\"Document sections can only be emitted to \" +\n                        \"web targets\");\n      if (options.section !== \"head\" && options.section !== \"body\")\n        throw new Error(\"'section' must be 'head' or 'body'\");\n      if (typeof options.data !== \"string\")\n        throw new Error(\"'data' option to appendDocument must be a string\");\n      resources.push({\n        type: options.section,\n        data: new Buffer(files.convertToStandardLineEndings(options.data), 'utf8')\n      });\n    },\n\n    /**\n     * @deprecated in 0.9.4\n     */\n    appendDocument: function (options) {\n      this.addHtml(options);\n    },\n\n    /**\n     * @summary Web targets only. Add a stylesheet to the document.\n     * @param {Object} options\n     * @param {String} path The requested path for the added CSS, may not be\n     * satisfied if there are path conflicts.\n     * @param {String} data The content of the stylesheet that should be\n     * added.\n     * @param {String} sourceMap A stringified JSON sourcemap, in case the\n     * stylesheet was generated from a different file.\n     * @memberOf CompileStep\n     * @instance\n     */\n    addStylesheet: function (options) {\n      if (! archinfo.matches(inputSourceArch.arch, \"web\"))\n        throw new Error(\"Stylesheets can only be emitted to \" +\n                        \"web targets\");\n      if (typeof options.data !== \"string\")\n        throw new Error(\"'data' option to addStylesheet must be a string\");\n      resources.push({\n        type: \"css\",\n        refreshable: true,\n        data: new Buffer(files.convertToStandardLineEndings(options.data), 'utf8'),\n        servePath: colonConverter.convert(\n          files.pathJoin(\n            inputSourceArch.pkg.serveRoot,\n            files.convertToStandardPath(options.path, true))),\n        sourceMap: convertSourceMapPaths(options.sourceMap,\n                                         files.convertToStandardPath)\n      });\n    },\n\n    /**\n     * @summary Add JavaScript code. The code added will only see the\n     * namespaces imported by this package as runtime dependencies using\n     * ['api.use'](#PackageAPI-use). If the file being compiled was added\n     * with the bare flag, the resulting JavaScript won't be wrapped in a\n     * closure.\n     * @param {Object} options\n     * @param {String} options.path The path at which the JavaScript file\n     * should be inserted, may not be honored in case of path conflicts.\n     * @param {String} options.data The code to be added.\n     * @param {String} options.sourcePath The path that will be used in\n     * any error messages generated by this file, e.g. `foo.js:4:1: error`.\n     * @memberOf CompileStep\n     * @instance\n     */\n    addJavaScript: function (options) {\n      if (typeof options.data !== \"string\")\n        throw new Error(\"'data' option to addJavaScript must be a string\");\n      if (typeof options.sourcePath !== \"string\")\n        throw new Error(\"'sourcePath' option must be supplied to addJavaScript. Consider passing inputPath.\");\n\n      // By default, use fileOptions for the `bare` option but also allow\n      // overriding it with the options\n      var bare = fileOptions.bare;\n      if (options.hasOwnProperty(\"bare\")) {\n        bare = options.bare;\n      }\n\n      var data = new Buffer(\n        files.convertToStandardLineEndings(options.data), 'utf8');\n      resources.push({\n        type: \"js\",\n        data: data,\n        // XXX Weirdly, we now ignore sourcePath even though we required\n        //     it before. We used to use it as the source path in source map\n        //     generated in linker. We now use the servePath for that, as of\n        //     b556e622. Not sure this is actually correct...\n        servePath: colonConverter.convert(\n          files.pathJoin(\n            inputSourceArch.pkg.serveRoot,\n            files.convertToStandardPath(options.path, true))),\n        hash: watch.sha1(data),\n        sourceMap: convertSourceMapPaths(options.sourceMap,\n                                         files.convertToStandardPath),\n        bare: !! bare\n      });\n    },\n\n    /**\n     * @summary Add a file to serve as-is to the browser or to include on\n     * the browser, depending on the target. On the web, it will be served\n     * at the exact path requested. For server targets, it can be retrieved\n     * using `Assets.getText` or `Assets.getBinary`.\n     * @param {Object} options\n     * @param {String} path The path at which to serve the asset.\n     * @param {Buffer|String} data The data that should be placed in\n     * the file.\n     * @memberOf CompileStep\n     * @instance\n     */\n    addAsset: function (options) {\n      if (! (options.data instanceof Buffer)) {\n        if (_.isString(options.data)) {\n          options.data = new Buffer(options.data);\n        } else {\n          throw new Error(\"'data' option to addAsset must be a Buffer or String.\");\n        }\n      }\n\n      addAsset(options.data, files.convertToStandardPath(options.path, true));\n    },\n\n    /**\n     * @summary Display a build error.\n     * @param  {Object} options\n     * @param {String} message The error message to display.\n     * @param {String} [sourcePath] The path to display in the error message.\n     * @param {Integer} line The line number to display in the error message.\n     * @param {String} func The function name to display in the error message.\n     * @memberOf CompileStep\n     * @instance\n     */\n    error: function (options) {\n      buildmessage.error(options.message || (\"error building \" + relPath), {\n        file: options.sourcePath,\n        line: options.line ? options.line : undefined,\n        column: options.column ? options.column : undefined,\n        func: options.func ? options.func : undefined\n      });\n    }\n  };\n\n  return compileStep;\n};\n"]}