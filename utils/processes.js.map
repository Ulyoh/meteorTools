{"version":3,"sources":["/tools/utils/processes.js"],"names":[],"mappings":"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","file":"tools/utils/processes.js.map","sourcesContent":["import _ from 'underscore';\nimport child_process from 'child_process';\n\n// The execFileSync function is meant to resemble the similarly-named Node 0.12\n// synchronous process creation API, but instead of being fully blocking it\n// uses a promise-based implementation. You can also use\n// execFileAsync directly, which returns a promise.\n// Some functionality is currently missing but could be added when the need\n// arises (e.g. support for timeout, maxBuffer, and encoding options).\n// Eventually, these versions should replace the ones in tools/utils/utils.js\n// and tools/tool-testing/selftest.js.\n\n/**\n * @summary Executes a command synchronously, returning either the captured\n * stdout output or throwing an error containing the stderr output as part of\n * the message. In addition, the error will contain fields pid, stderr, stdout,\n * status and signal.\n * @param {String} command The command to run\n * @param {Array} [args] List of string arguments\n * @param {Object} [options]\n * @param {Object} [options.cwd] Current working directory of the child process\n * @param {Object} [options.env] Environment key-value pairs\n * @param {Array|String} [options.stdio] Child's stdio configuration.\n * (Default: 'pipe') Specifying anything else than 'pipe' will disallow\n * capture.\n * @param {Writable} [options.destination] If specified, instead of capturing\n * the output, the child process stdout will be piped to the destination stream.\n * @param {String} [options.waitForClose] Whether to wait for the child process\n * streams to close or to resolve the promise when the child process exits.\n * @returns {String} The stdout from the command\n */\nexport function execFileSync(command, args, options) {\n  return Promise.await(execFileAsync(command, args, options));\n}\n\n/**\n * @summary Executes a command asynchronously, returning a promise that will\n * either be resolved to the captured stdout output or be rejected with an\n * error containing the stderr output as part of the message. In addition,\n * the error will contain fields pid, stderr, stdout, status and signal.\n * @param {String} command The command to run\n * @param {Array} [args] List of string arguments\n * @param {Object} [options]\n * @param {Object} [options.cwd] Current working directory of the child process\n * @param {Object} [options.env] Environment key-value pairs\n * @param {Array|String} [options.stdio] Child's stdio configuration.\n * (Default: 'pipe') Specifying anything else than 'pipe' will disallow\n * capture.\n * @param {Writable} [options.destination] If specified, instead of capturing\n * the output, the child process stdout will be piped to the destination stream.\n * @param {String} [options.waitForClose] Whether to wait for the child process\n * streams to close or to resolve the promise when the child process exits.\n * @returns {Promise<String>}\n */\nexport function execFileAsync(command, args,\n  options = { waitForClose: true }) {\n  // args is optional, so if it's not an array we interpret it as options\n  if (!Array.isArray(args)) {\n    options = _.extend(options, args);\n    args = [];\n  }\n\n  // The child process close event is emitted when the stdio streams\n  // have all terminated. If those streams are shared with other\n  // processes, that means we won't receive a 'close' until all processes\n  // have exited, so we may want to respond to 'exit' instead.\n  // (The downside of responding to 'exit' is that the streams may not be\n  // fully flushed, so we could miss captured output. Only use this\n  // option when needed.)\n  const exitEvent = options.waitForClose ? 'close' : 'exit';\n\n  return new Promise((resolve, reject) => {\n    const child = child_process.spawn(command, args,\n      { cwd, env, stdio } = options);\n\n    let capturedStdout = '';\n    if (child.stdout) {\n      if (options.destination) {\n        child.stdout.pipe(options.destination);\n      } else {\n        child.stdout.setEncoding('utf8');\n        child.stdout.on('data', (data) => {\n          capturedStdout += data;\n        });\n      }\n    }\n\n    let capturedStderr = '';\n    if (child.stderr) {\n      child.stderr.setEncoding('utf8');\n      child.stderr.on('data', (data) => {\n        capturedStderr += data;\n      });\n    }\n\n    const errorCallback = (error) => {\n      // Make sure we only receive one type of callback\n      child.removeListener(exitEvent, exitCallback);\n\n      // Trim captured output to get rid of excess whitespace\n      capturedStdout = capturedStdout.trim();\n      capturedStderr = capturedStderr.trim();\n\n      _.extend(error, {\n        pid: child.pid,\n        stdout: capturedStdout,\n        stderr: capturedStderr,\n      });\n\n      // Set a more informative error message on ENOENT, that includes the\n      // command we attempted to execute\n      if (error.code === 'ENOENT') {\n        error.message = `Could not find command '${command}'`;\n      }\n\n      reject(error);\n    };\n    child.on('error', errorCallback);\n\n    const exitCallback = (code, signal) => {\n      // Make sure we only receive one type of callback\n      child.removeListener('error', errorCallback);\n\n      // Trim captured output to get rid of excess whitespace\n      capturedStdout = capturedStdout.trim();\n      capturedStderr = capturedStderr.trim();\n\n      if (code === 0) {\n        resolve(capturedStdout);\n      } else {\n        let errorMessage = `Command failed: ${command}`;\n        if (args) {\n          errorMessage += ` ${args.join(' ')}`;\n        }\n        errorMessage += `\\n${capturedStderr}`;\n\n        const error = new Error(errorMessage);\n\n        _.extend(error, {\n          pid: child.pid,\n          stdout: capturedStdout,\n          stderr: capturedStderr,\n          status: code,\n          signal: signal\n        });\n\n        reject(error);\n      }\n    };\n    child.on(exitEvent, exitCallback);\n  });\n}\n"]}