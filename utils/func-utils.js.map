{"version":3,"sources":["/tools/utils/func-utils.js"],"names":[],"mappings":";;;AAGA,OAAO,CAAC,QAAQ,GAAG,UAAS,OAAO,EAAE,QAAQ,EAAE,OAAO,EAAE;AACtD,MAAI,YAAY,GAAG,IAAI,CAAC;AACxB,MAAI,UAAU,GAAG,CAAC,CAAC;;AAEnB,SAAO,GAAG,OAAO,IAAI,GAAG,CAAC;;AAEzB,WAAS,iBAAiB,GAAG;AAC3B,QAAI,IAAI,GAAG,OAAO,IAAI,IAAI,CAAC;;AAE3B,QAAI,UAAU,EAAE;;;AAGd,QAAE,UAAU,CAAC;AACb,aAAO;KACR;;AAED,QAAI,YAAY,KAAK,IAAI,EAAE;;AAEzB,aAAO;KACR;;AAED,QAAI,aAAa,GAAG,OAAO,CAAC,oBAAoB,CAAC,CAAC,WAAW,CAAC,YAAW;;;;;;AAMvE,kBAAY,GAAG,IAAI,CAAC;AACpB,gBAAU,GAAG,CAAC,CAAC;;AAEf,UAAI;AACF,gBAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;OACrB,SAAS;AACR,YAAI,UAAU,GAAG,CAAC,EAAE;AAClB,iBAAO,CAAC,QAAQ,CAAC,aAAa,CAAC,CAAC;AAChC,sBAAY,GAAG,IAAI,CAAC;SACrB;AACD,kBAAU,GAAG,CAAC,CAAC;OAChB;KACF,CAAC,CAAC;;AAEH,gBAAY,GAAG,UAAU,CAAC,aAAa,EAAE,OAAO,CAAC,CAAC;GACnD;;AAED,SAAO,IAAI,CAAC,iBAAiB,EAAE,QAAQ,CAAC,CAAC;CAC1C,CAAC;;AAEF,SAAS,IAAI,CAAC,OAAO,EAAE,OAAO,EAAE;;;AAG9B,SAAO,CAAC,SAAS,GAAG,OAAO,CAAC,SAAS,CAAC;;;AAGtC,MAAI,IAAI,GAAG,OAAO,CAAC,WAAW,IAAI,OAAO,CAAC,IAAI,CAAC;AAC/C,MAAI,IAAI,EAAE;AACR,WAAO,CAAC,WAAW,GAAG,IAAI,CAAC;GAC5B;;AAED,SAAO,OAAO,CAAC;CAChB","file":"tools/utils/func-utils.js.map","sourcesContent":["// Return a function that coalesceses calls to fn that occur within delay\n// milliseconds of each other, and prevents overlapping invocations of fn\n// by postponing the next invocation until after fn's fiber finishes.\nexports.coalesce = function(delayMs, callback, context) {\n  var pendingTimer = null;\n  var inProgress = 0;\n\n  delayMs = delayMs || 100;\n\n  function coalescingWrapper() {\n    var self = context || this;\n\n    if (inProgress) {\n      // Indicate that coalescingWrapper should be called again after the\n      // callback is no longer in progress.\n      ++inProgress;\n      return;\n    }\n\n    if (pendingTimer !== null) {\n      // Defer to the already-pending timer.\n      return;\n    }\n\n    var fiberCallback = require('./fiber-helpers.js').inBareFiber(function() {\n      // Now that the timeout has fired, set inProgress to 1 so that\n      // (until the callback is complete and we set inProgress to 0 again)\n      // any calls to coalescingWrapper will increment inProgress to\n      // indicate that at least one other caller wants fiberCallback to be\n      // called again when the original callback is complete.\n      pendingTimer = null;\n      inProgress = 1;\n\n      try {\n        callback.call(self);\n      } finally {\n        if (inProgress > 1) {\n          process.nextTick(fiberCallback);\n          pendingTimer = true;\n        }\n        inProgress = 0;\n      }\n    });\n\n    pendingTimer = setTimeout(fiberCallback, delayMs);\n  }\n\n  return wrap(coalescingWrapper, callback);\n};\n\nfunction wrap(wrapper, wrapped) {\n  // Allow the wrapper to be used as a constructor function, just in case\n  // the wrapped function was meant to be used as a constructor.\n  wrapper.prototype = wrapped.prototype;\n\n  // https://medium.com/@cramforce/on-the-awesomeness-of-fn-displayname-9511933a714a\n  var name = wrapped.displayName || wrapped.name;\n  if (name) {\n    wrapper.displayName = name;\n  }\n\n  return wrapper;\n}\n"]}