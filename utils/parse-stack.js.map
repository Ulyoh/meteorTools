{"version":3,"sources":["/tools/utils/parse-stack.js"],"names":[],"mappings":"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","file":"tools/utils/parse-stack.js.map","sourcesContent":["const _ = require('underscore');\n\n// Given an Error (eg, 'new Error'), return the stack associated with\n// that error as an array. More recently called functions appear first\n// and each element is an object with keys:\n// - file: filename as it appears in the stack\n// - line: 1-indexed line number in file, as a Number\n// - column: 1-indexed column in line, as a Number\n// - func: name of the function in the frame (maybe null)\n//\n// Accomplishes this by parsing the text representation of the stack\n// with regular expressions. Unlikely to work anywhere but v8.\n//\n// If a function on the stack has been marked with mark(), don't\n// return anything past that function. We call this the \"user portion\"\n// of the stack.\nexport function parse(err) {\n  const frames = err.stack.split('\\n');\n\n  frames.shift(); // at least the first line is the exception\n\n  // \"    - - - - -\"\n  // This is something added when you throw an Error through a Future. The\n  // stack above the dashes is the stack of the 'wait' call; the stack below\n  // is the stack inside the fiber where the Error is originally\n  // constructed.\n  // XXX This code assumes that the stack trace can only be split once. It's not\n  // clear whether this can happen multiple times.\n  const indexOfFiberSplit = frames.indexOf('    - - - - -');\n\n  if (indexOfFiberSplit === -1) {\n    // This is a normal stack trace, not a split fiber stack trace\n    return {\n      outsideFiber: parseStackFrames(frames)\n    }\n  }\n\n  // If this is a split stack trace from a future, parse the frames above and\n  // below the split separately.\n  const outsideFiber = parseStackFrames(frames);\n  const insideFiber = parseStackFrames(frames.slice(indexOfFiberSplit + 1));\n\n  return {\n    insideFiber,\n    outsideFiber\n  };\n}\n\n// Decorator. Mark the point at which a stack trace returned by\n// parse() should stop: no frames earlier than this point will be\n// included in the parsed stack. Confusingly, in the argot of the\n// times, you'd say that frames \"higher up\" than this or \"above\" this\n// will not be returned, but you'd also say that those frames are \"at\n// the bottom of the stack\". Frames below the bottom are the outer\n// context of the framework running the user's code.\nexport function markBottom(f) {\n  /* eslint-disable camelcase */\n  return function __bottom_mark__() {\n    return f.apply(this, arguments);\n  };\n  /* eslint-enable camelcase */\n}\n\n// Decorator. Mark the point at which a stack trace returned by\n// parse() should begin: no frames later than this point will be\n// included in the parsed stack. The opposite of markBottom().\n// Frames above the top are helper functions defined by the\n// framework and executed by user code whose internal behavior\n// should not be exposed.\nexport function markTop(f) {\n  /* eslint-disable camelcase */\n  return function __top_mark__() {\n    return f.apply(this, arguments);\n  };\n  /* eslint-enable camelcase */\n}\n\nfunction parseStackFrames(frames) {\n  let stop = false;\n  let ret = [];\n  frames.forEach((frame) => {\n    if (stop) {\n      return;\n    }\n\n    let m;\n\n    /* eslint-disable max-len */\n    if (m = frame.match(/^\\s*at\\s*((new )?.+?)\\s*(\\[as\\s*([^\\]]*)\\]\\s*)?\\((.*?)(:(\\d+))?(:(\\d+))?\\)\\s*$/)) {\n      // https://code.google.com/p/v8/wiki/JavaScriptStackTraceApi\n      // \"    at My.Function (/path/to/myfile.js:532:39)\"\n      // \"    at Array.forEach (native)\"\n      // \"    at new My.Class (file.js:1:2)\"\n      // \"    at [object Object].main.registerCommand.name [as func] (meteor/tools/commands.js:1225:19)\"\n      // \"    at __top_mark__ [as matchErr] (meteor/tools/parse-stack.js:82:14)\"\n      //\n      // In that last example, it is not at all clear to me what the\n      // 'as' stanza refers to, but it is in m[3] if you find a use for it.\n      if (m[1].match(/(?:^|\\.)__top_mark__$/)) {\n        // m[1] could be Object.__top_mark__ or something like that\n        // depending on where exactly you put the function returned by\n        // markTop\n        ret = [];\n        return;\n      }\n      if (m[1].match(/(?:^|\\.)__bottom_mark__$/)) {\n        stop = true;\n        return;\n      }\n      ret.push({\n        func: m[1],\n        file: m[5],\n        line: m[7] ? +m[7] : undefined,\n        column: m[9] ? +m[9] : undefined\n      });\n      return;\n    }\n    /* eslint-enable max-len */\n\n    if (m = frame.match(/^\\s*at\\s+(.+?)(:(\\d+))?(:(\\d+))?\\s*$/)) {\n      // \"    at /path/to/myfile.js:532:39\"\n      ret.push({\n        file: m[1],\n        line: m[3] ? +m[3] : undefined,\n        column: m[5] ? +m[5] : undefined\n      });\n      return;\n    }\n\n    if (m = frame.match(/^\\s*-\\s*-\\s*-\\s*-\\s*-\\s*$/)) {\n      // Stop parsing if we reach a stack split from a Future\n      stop = true;\n      return;\n    }\n\n    if (_.isEmpty(ret)) {\n      // We haven't found any stack frames, so probably we have newlines in the\n      // error message. Just skip this line.\n      return;\n    }\n\n    throw new Error(\"Couldn't parse stack frame: '\" + frame + \"'\");\n  });\n\n  return ret;\n}\n"]}