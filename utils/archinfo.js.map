{"version":3,"sources":["/tools/utils/archinfo.js"],"names":[],"mappings":"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","file":"tools/utils/archinfo.js.map","sourcesContent":["var _ = require('underscore');\nvar os = require('os');\n\nvar utils = require('./utils.js');\n\n/* Meteor's current architecture scheme defines the following virtual\n * machine types, which are defined by specifying what is promised by\n * the host enviroment:\n *\n * browser.w3c\n *   A web browser compliant with modern standards. This is\n *   intentionally a broad definition. In the coming years, as web\n *   standards evolve, we will likely tighten it up.\n *\n * browser.ie[678]\n *   Old versions of Internet Explorer (not sure yet exactly which\n *   versions to distinguish -- maybe 6 and 8?)\n *\n * os.linux.x86_32\n * os.linux.x86_64\n *   Linux on Intel x86 architecture. x86_64 means a system that can\n *   run 64-bit images, furnished with 64-bit builds of shared\n *   libraries (there is no guarantee that 32-bit builds of shared\n *   libraries will be available). x86_32 means a system that can run\n *   32-bit images, furnished with 32-bit builds of shared libraries.\n *   Additionally, if a package contains shared libraries (for use by\n *   other packages), then if the package is built for x86_64, it\n *   should contain a 64-bit version of the library, and likewise for\n *   32-bit.\n *\n *   Operationally speaking, if you worked at it, under this\n *   definition it would be possible to build a Linux system that can\n *   run both x86_64 and x86_32 images (eg, by using a 64-bit kernel\n *   and making sure that both versions of all relevant libraries were\n *   installed). But we require such a host to decide whether it is\n *   x86_64 or x86_32, and stick with it. You can't load a combination\n *   of packages from each and expect them to work together, because\n *   if they contain shared libraries they all need to have the same\n *   architecture.\n *\n *   Basically the punchline is: if you installed the 32-bit version\n *   of Ubuntu, you've got a os.linux.x86_32 system and you will\n *   use exclusively os.linux.x86_32 packages, and likewise\n *   64-bit. They are two parallel universes and which one you're in\n *   is determined by which version of Red Hat or Ubuntu you\n *   installed.\n *\n * os.osx.x86_64\n *   OS X (technically speaking, Darwin) on Intel x86 architecture,\n *   with a kernel capable of loading 64-bit images, and 64-bit builds\n *   of shared libraries available.  If a os.osx.x86_64 package\n *   contains a shared library, it is only required to provide a\n *   64-bit version of the library (it is not required to provide a\n *   fat binary with both 32-bit and 64-bit builds).\n *\n *   Note that in modern Darwin, both the 32 and 64 bit versions of\n *   the kernel can load 64-bit images, and the Apple-supplied shared\n *   libraries are fat binaries that include both 32-bit and 64-bit\n *   builds in a single file. So it is technically fine (but\n *   discouraged) for a os.osx.x86_64 to include a 32-bit\n *   executable, if it only uses the system's shared libraries, but\n *   you'll run into problems if shared libraries from other packages\n *   are used.\n *\n *   There is no os.osx.x86_32. Our experience is that such\n *   hardware is virtually extinct. Meteor has never supported it and\n *   nobody has asked for it.\n *\n * os.windows.x86_32\n *   This is 32 and 64 bit Windows. It seems like there is not much of\n *   a benefit to using 64 bit Node on Windows, and 32 bit works properly\n *   even on 64 bit systems.\n *\n * To be (more but far from completely) precise, the ABI for os.*\n * architectures includes a CPU type, a mode in which the code will be\n * run (eg, 64 bit), an executable file format (eg, ELF), a promise to\n * make any shared libraries available in a particular architecture,\n * and promise to set up the shared library search path\n * \"appropriately\". In the future it will also include some guarantees\n * about the directory layout in the environment, eg, location of a\n * directory where temporary files may be freely written. It does not\n * include any syscalls (beyond those used by code that customarily is\n * statically linked into every executable built on a platform, eg,\n * exit(2)). It does not guarantee the presence of any particular\n * shared libraries or programs (including any particular shell or\n * traditional tools like 'grep' or 'find').\n *\n * To model the shared libraries that are required on a system (and\n * the particular versions that are required), and to model\n * dependencies on command-line programs like 'bash' and 'grep', the\n * idea is to have a package named something like 'posix-base' that\n * rolls up a reasonable base environment (including such modern\n * niceties as libopenssl) and is supplied by the container. This\n * allows it to be versioned, unlike architectures, which we hope to\n * avoid versioning.\n *\n * Q: What does \"x86\" mean?\n * A: It refers to the traditional Intel architecture, which\n * originally surfaced in CPUs such as the 8086 and the 80386. Those\n * of us who are older should remember that the last time that Intel\n * used this branding was the 80486, introduced in 1989, and that\n * today, parts that use this architecture bear names like \"Core\",\n * \"Atom\", and \"Phenom\", with no \"86\" it sight. We use it in the\n * architecture name anyway because we don't want to depart too far\n * from Linux's architecture names.\n *\n * Q: Why do we call it \"x86_32\" instead of the customary \"i386\" or\n * \"i686\"?\n * A: We wanted to have one name for 32-bit and one name for 64-bit,\n * rather than several names for each that are virtual synonyms for\n * each (eg, x86_64 vs amd64 vs ia64, i386 vs i686 vs x86). For the\n * moment anyway, we're willing to adopt a \"one size fits all\"\n * attitude to get there (no ability to have separate builds for 80386\n * CPUs that don't support Pentium Pro extensions, for example --\n * you'll have to do runtime detection if you need that). And as long\n * as we have to pick a name, we wanted to pick one that was super\n * clear (it is not obvious to many people that \"i686\" means \"32-bit\n * Intel\", because why should it be?) and didn't imply too close of an\n * equivalence to the precise meanings that other platforms may assign\n * to some of these strings.\n */\n\n\n// Returns the fully qualified arch of this host -- something like\n// \"os.linux.x86_32\" or \"os.osx.x86_64\". Must be called inside\n// a fiber. Throws an error if it's not a supported architecture.\n//\n// If you change this, also change scripts/admin/launch-meteor\nvar _host = null; // memoize\nvar host = function () {\n  if (! _host) {\n    var run = function (...args) {\n      var result = utils.execFileSync(args[0], args.slice(1)).stdout;\n      if (! result)\n        throw new Error(\"can't get arch with \" + args.join(\" \") + \"?\");\n      return result.replace(/\\s*$/, ''); // trailing whitespace\n    };\n\n    var platform = os.platform();\n\n    if (platform === \"darwin\") {\n      // Can't just test uname -m = x86_64, because Snow Leopard can\n      // return other values.\n      if (run('uname', '-p') !== \"i386\" ||\n          run('sysctl', '-n', 'hw.cpu64bit_capable') !== \"1\")\n        throw new Error(\"Only 64-bit Intel processors are supported on OS X\");\n      _host  = \"os.osx.x86_64\";\n    }\n\n    else if (platform === \"linux\") {\n      var machine = run('uname', '-m');\n      if (_.contains([\"i386\", \"i686\", \"x86\"], machine))\n        _host = \"os.linux.x86_32\";\n      else if (_.contains([\"x86_64\", \"amd64\", \"ia64\"], machine))\n        _host = \"os.linux.x86_64\";\n      else\n        throw new Error(\"Unsupported architecture: \" + machine);\n    }\n\n    else if (platform === \"win32\") {\n      // We also use 32 bit builds on 64 bit Windows architectures.\n      _host = \"os.windows.x86_32\";\n    }\n\n    else\n      throw new Error(\"Unsupported operating system: \" + platform);\n  }\n\n  return _host;\n};\n\n// True if `host` (an architecture name such as 'os.linux.x86_64') can run\n// programs of architecture `program` (which might be something like 'os',\n// 'os.linux', or 'os.linux.x86_64').\n//\n// `host` and `program` are just mnemonics -- `host` does not\n// necessariy have to be a fully qualified architecture name. This\n// function just checks to see if `program` describes a set of\n// enviroments that is a (non-strict) superset of `host`.\nvar matches = function (host, program) {\n  return host.substr(0, program.length) === program &&\n    (host.length === program.length ||\n     host.substr(program.length, 1) === \".\");\n};\n\n// Like `supports`, but instead taken an array of possible\n// architectures as its second argument. Returns the most specific\n// match, or null if none match. Throws an error if `programs`\n// contains exact duplicates.\nvar mostSpecificMatch = function (host, programs) {\n  var seen = {};\n  var best = null;\n\n  _.each(programs, function (p) {\n    if (seen[p])\n      throw new Error(\"Duplicate architecture: \" + p);\n    seen[p] = true;\n    if (archinfo.matches(host, p) &&\n        (! best || p.length > best.length))\n      best = p;\n  });\n\n  return best;\n};\n\n// `programs` is a set of architectures (as an array of string, which\n// may contain duplicates). Determine if there exists any architecture\n// that is compatible with all of the architectures in the set. If so,\n// returns the least specific such architecture. Otherwise (the\n// architectures are disjoin) raise an exception.\n//\n// For example, for 'os' and 'os.osx', return 'os.osx'. For 'os' and\n// 'os.linux.x86_64', return 'os.linux.x86_64'. For 'os' and 'browser', throw an\n// exception.\nvar leastSpecificDescription = function (programs) {\n  if (programs.length === 0)\n    return '';\n\n  // Find the longest string\n  var longest = _.max(programs, function (p) { return p.length; });\n\n  // If everything else in the list is compatible with the longest,\n  // then it must be the most specific, and if everything is\n  // compatible with the most specific then it must be the least\n  // specific compatible description.\n  _.each(programs, function (p) {\n    if (! archinfo.matches(longest, p))\n      throw new Error(\"Incompatible architectures: '\" + p + \"' and '\" +\n                      longest + \"'\");\n  });\n\n  return longest;\n};\n\nvar withoutSpecificOs = function (arch) {\n  if (arch.substr(0, 3) === 'os.')\n    return 'os';\n  return arch;\n};\n\nvar archinfo = exports;\n_.extend(archinfo, {\n  host: host,\n  matches: matches,\n  mostSpecificMatch: mostSpecificMatch,\n  leastSpecificDescription: leastSpecificDescription,\n  withoutSpecificOs: withoutSpecificOs\n});\n"]}