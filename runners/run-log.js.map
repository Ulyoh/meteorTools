{"version":3,"sources":["/tools/runners/run-log.js"],"names":[],"mappings":"AAAA,IAAI,CAAC,GAAG,OAAO,CAAC,YAAY,CAAC,CAAC;AAC9B,IAAI,UAAU,GAAG,OAAO,CAAC,2BAA2B,CAAC,CAAC;AACtD,IAAI,OAAO,GAAG,OAAO,CAAC,uBAAuB,CAAC,CAAC,OAAO,CAAC;;;;;;;;;;;;;;;;AAiBvD,IAAI,iBAAiB,GAAG,YAAY;AAClC,MAAI,GAAG,GAAG,UAAU,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,CAAC,GAAG,CAAC;;;;AAIjD,KAAG,CAAC,YAAY,GAAG,cAAc,CAAC;;AAElC,SAAO,GAAG,CAAC;CACZ,CAAC;;AAEF,IAAI,MAAM,GAAG,YAAY;AACvB,MAAI,IAAI,GAAG,IAAI,CAAC;;AAEhB,MAAI,CAAC,OAAO,GAAG,KAAK,CAAC;;AAErB,MAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;AACnB,MAAI,CAAC,SAAS,GAAG,GAAG,CAAC;;;;;AAKrB,MAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC;AACvC,MAAI,CAAC,gCAAgC,GAAG,IAAI,CAAC;;;;;AAK7C,MAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC;CACpC,CAAC;;AAEF,CAAC,CAAC,MAAM,CAAC,MAAM,CAAC,SAAS,EAAE;AACzB,SAAO,EAAE,UAAU,GAAG,EAAE;AACtB,QAAI,IAAI,GAAG,IAAI,CAAC;;AAEhB,QAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AACxB,QAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,IAAI,CAAC,SAAS,EAAE;AACzC,UAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC;KACvB;GACF;;AAED,eAAa,EAAE,YAAY;AACzB,QAAI,IAAI,GAAG,IAAI,CAAC;;AAEhB,QAAI,IAAI,CAAC,0BAA0B,EAAE;AACnC,UAAI,CAAC,0BAA0B,GAAG,IAAI,CAAC;AACvC,aAAO,CAAC,IAAI,EAAE,CAAC;KAChB;;AAED,QAAI,IAAI,CAAC,gCAAgC,EAAE;AACzC,UAAI,CAAC,gCAAgC,GAAG,IAAI,CAAC;AAC7C,aAAO,CAAC,IAAI,EAAE,CAAC;KAChB;;AAED,QAAI,IAAI,CAAC,sBAAsB,EAAE;AAC/B,UAAI,MAAM,GAAG,IAAI,KAAK,CAAC,IAAI,CAAC,sBAAsB,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;AAClE,aAAO,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC;AACvD,UAAI,CAAC,sBAAsB,GAAG,IAAI,CAAC;KACpC;GACF;;AAED,YAAU,EAAE,UAAU,OAAO,EAAE;AAC7B,QAAI,CAAC,OAAO,GAAG,CAAC,CAAC,OAAO,CAAC;GAC1B;;AAED,cAAY,EAAE,UAAU,IAAI,EAAE,QAAQ,EAAE;AACtC,QAAI,IAAI,GAAG,IAAI,CAAC;;AAEhB,QAAI,GAAG,GAAG,iBAAiB,EAAE,CAAC;;AAE9B,QAAI,GAAG,GAAI,QAAQ,GACR,GAAG,CAAC,WAAW,CAAC,IAAI,EAAE,EAAE,KAAK,EAAE,MAAM,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,GACtD,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,IAAI,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,AAAC,CAAC;AACrD,QAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;;AAElB,QAAI,CAAC,aAAa,EAAE,CAAC;AACrB,QAAI,IAAI,CAAC,OAAO,EACd,OAAO,CAAC,QAAQ,GAAG,UAAU,GAAG,SAAS,CAAC,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,KAExD,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,MAAM,CAAC,GAAG,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC;;;GAG5D;;;;;;AAMD,KAAG,EAAE,UAAU,GAAG,EAAE,OAAO,EAAE;AAC3B,QAAI,IAAI,GAAG,IAAI,CAAC;AAChB,WAAO,GAAG,OAAO,IAAI,EAAE,CAAC;AACxB,QAAI,GAAG,GAAG;AACR,UAAI,EAAE,IAAI,IAAI,EAAA;AACd,aAAO,EAAE,GAAG;;;;KAIb,CAAC;AACF,QAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC;;AAElB,QAAI,CAAC,aAAa,EAAE,CAAC;;;;;AAKrB,WAAO,CAAC,OAAO,CAAC,KAAK,GAAG,WAAW,GAAG,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC;GACpD;;;;;;;;;;AAUD,cAAY,EAAE,UAAU,GAAG,EAAE;AAC3B,QAAI,IAAI,GAAG,IAAI,CAAC;;AAEhB,QAAI,CAAC,aAAa,EAAE,CAAC;AACrB,WAAO,CAAC,MAAM,CAAC,KAAK,CAAC,GAAG,GAAG,OAAO,CAAC,eAAe,CAAC,CAAC;AACpD,QAAI,CAAC,sBAAsB,GAAG,GAAG,CAAC,MAAM,CAAC;GAC1C;;AAED,YAAU,EAAE,YAAY;AACtB,QAAI,IAAI,GAAG,IAAI,CAAC;;AAEhB,QAAI,IAAI,CAAC,0BAA0B,EAAE;;;AAGnC,aAAO,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;AAC9C,UAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;AACpB,UAAI,CAAC,0BAA0B,EAAG,CAAC;KACpC,MAAM;AACL,UAAI,CAAC,aAAa,EAAE,CAAC;AACrB,UAAI,CAAC,0BAA0B,GAAG,CAAC,CAAC;KACrC;;AAED,QAAI,OAAO,GAAG,4BAA4B,CAAC;AAC3C,QAAI,IAAI,CAAC,0BAA0B,GAAG,CAAC,EACrC,OAAO,IAAI,KAAK,GAAG,IAAI,CAAC,0BAA0B,GAAG,GAAG,CAAC;;;AAG3D,WAAO,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;;AAE9B,QAAI,CAAC,OAAO,CAAC;AACX,UAAI,EAAE,IAAI,IAAI,EAAA;AACd,aAAO,EAAE,OAAO;KACjB,CAAC,CAAC;GACJ;;AAED,kBAAgB,EAAE,YAAY;AAC5B,QAAI,IAAI,GAAG,IAAI,CAAC;;AAEhB,QAAI,IAAI,CAAC,gCAAgC,EAAE;;;AAGzC,aAAO,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;AAC9C,UAAI,CAAC,QAAQ,CAAC,GAAG,EAAE,CAAC;AACpB,UAAI,CAAC,gCAAgC,EAAG,CAAC;KAC1C,MAAM;AACL,UAAI,CAAC,aAAa,EAAE,CAAC;AACrB,UAAI,CAAC,gCAAgC,GAAG,CAAC,CAAC;KAC3C;;AAED,QAAI,OAAO,GAAG,kCAAkC,CAAC;AACjD,QAAI,IAAI,CAAC,gCAAgC,GAAG,CAAC,EAC3C,OAAO,IAAI,KAAK,GAAG,IAAI,CAAC,gCAAgC,GAAG,GAAG,CAAC;;;AAGjE,WAAO,CAAC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;;AAE9B,QAAI,CAAC,OAAO,CAAC;AACX,UAAI,EAAE,IAAI,IAAI,EAAA;AACd,aAAO,EAAE,OAAO;KACjB,CAAC,CAAC;GACJ;;AAED,QAAM,EAAE,YAAY;AAClB,QAAI,IAAI,GAAG,IAAI,CAAC;;AAEhB,QAAI,CAAC,aAAa,EAAE,CAAC;GACtB;;AAED,UAAQ,EAAE,YAAY;AACpB,QAAI,IAAI,GAAG,IAAI,CAAC;AAChB,QAAI,CAAC,QAAQ,GAAG,EAAE,CAAC;GACpB;;AAED,QAAM,EAAE,YAAY;AAClB,QAAI,IAAI,GAAG,IAAI,CAAC;AAChB,WAAO,IAAI,CAAC,QAAQ,CAAC;GACtB;CACF,CAAC,CAAC;;;;AAIH,IAAI,cAAc,GAAG,IAAI,MAAM,EAAA,CAAC;AAChC,CAAC,CAAC,IAAI,CACJ,CAAC,KAAK,EAAE,cAAc,EAAE,YAAY,EAAE,kBAAkB,EAAE,cAAc,EACvE,YAAY,EAAE,QAAQ,EAAE,UAAU,EAAE,QAAQ,CAAC,EAC9C,UAAU,MAAM,EAAE;AAChB,SAAO,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,MAAM,CAAC,EAAE,cAAc,CAAC,CAAC;CAClE,CAAC,CAAC","file":"tools/runners/run-log.js.map","sourcesContent":["var _ = require('underscore');\nvar isopackets = require('../tool-env/isopackets.js');\nvar Console = require('../console/console.js').Console;\n\n// runLog is primarily used by the parts of the tool which run apps locally. It\n// writes to standard output (and standard error, if rawLogs is set), and allows\n// special output forms like \"write this line, but let the next line overwrite\n// it\". It also makes its output available to the proxy, to be displayed to web\n// browsers if the app fails to run.\n//\n// It's not the only mechanism used for gathering messages! buildmessage is a\n// more structured way of gathering messages, but unlike log, it does not print\n// messages immediately.\n//\n// Some other parts of the code (eg commands and warehouse) write directly to\n// process.std{out,err} or to console.log; we should be careful to not do that\n// anywhere that may overlap with use of runLog.\n\n\nvar getLoggingPackage = function () {\n  var Log = isopackets.load('logging').logging.Log;\n\n  // Since no other process will be listening to stdout and parsing it,\n  // print directly in the same format as log messages from other apps\n  Log.outputFormat = 'colored-text';\n\n  return Log;\n};\n\nvar RunLog = function () {\n  var self = this;\n\n  self.rawLogs = false;\n\n  self.messages = []; // list of log objects\n  self.maxLength = 100;\n\n  // If non-null, the last thing logged was \"server restarted\"\n  // message, and the value will be the number of consecutive such\n  // messages that have been logged with no other intervening messages\n  self.consecutiveRestartMessages = null;\n  self.consecutiveClientRestartMessages = null;\n\n  // If non-null, the last thing that was logged was a temporary\n  // message (with a carriage return but no newline), and this is its\n  // length.\n  self.temporaryMessageLength = null;\n};\n\n_.extend(RunLog.prototype, {\n  _record: function (msg) {\n    var self = this;\n\n    self.messages.push(msg);\n    if (self.messages.length > self.maxLength) {\n      self.messages.shift();\n    }\n  },\n\n  _clearSpecial: function () {\n    var self = this;\n\n    if (self.consecutiveRestartMessages) {\n      self.consecutiveRestartMessages = null;\n      Console.info();\n    }\n\n    if (self.consecutiveClientRestartMessages) {\n      self.consecutiveClientRestartMessages = null;\n      Console.info();\n    }\n\n    if (self.temporaryMessageLength) {\n      var spaces = new Array(self.temporaryMessageLength + 1).join(' ');\n      process.stdout.write(spaces + Console.CARRIAGE_RETURN);\n      self.temporaryMessageLength = null;\n    }\n  },\n\n  setRawLogs: function (rawLogs) {\n    this.rawLogs = !!rawLogs;\n  },\n\n  logAppOutput: function (line, isStderr) {\n    var self = this;\n\n    var Log = getLoggingPackage();\n\n    var obj = (isStderr ?\n               Log.objFromText(line, { level: 'warn', stderr: true }) :\n               Log.parse(line) || Log.objFromText(line));\n    self._record(obj);\n\n    self._clearSpecial();\n    if (self.rawLogs)\n      Console[isStderr ? \"rawError\" : \"rawInfo\"](line + \"\\n\");\n    else\n      Console.rawInfo(Log.format(obj, { color: true }) + \"\\n\");\n\n    // XXX deal with test server logging differently?!\n  },\n\n  // Log the message.\n  //  msg: message\n  //  options:\n  //    - arrow: if true, preface with => and wrap accordingly.\n  log: function (msg, options) {\n    var self = this;\n    options = options || {};\n    var obj = {\n      time: new Date,\n      message: msg\n      // in the future, might want to add something else to\n      // distinguish messages from runner from message from the app,\n      // but for now, nothing would use it, so we'll keep it simple\n    };\n    self._record(obj);\n\n    self._clearSpecial();\n\n    // Process the options. By default, we want to wordwrap the message with\n    // Console.info. If we ask for raw output, then we don't want to do that. If\n    // we ask for an arrow, we want to wrap around with => as the bulletPoint.\n    Console[options.arrow ? 'arrowInfo' : 'info'](msg);\n  },\n\n  // Write a message to the terminal that will get overwritten by the\n  // next message logged. (Don't put it in the log that getLog\n  // returns.)\n  // XXX Maybe this should return an object that you have to pass to the\n  //     subsequent log call, and only such a log call will overwrite it (and an\n  //     intervening log call will cause this to stay on the screen)?\n  //     eg, a log call from the updater can interweave with the logTemporary\n  //     calls in run-all.js\n  logTemporary: function (msg) {\n    var self = this;\n\n    self._clearSpecial();\n    process.stdout.write(msg + Console.CARRIAGE_RETURN);\n    self.temporaryMessageLength = msg.length;\n  },\n\n  logRestart: function () {\n    var self = this;\n\n    if (self.consecutiveRestartMessages) {\n      // replace old message in place. this assumes that the new restart message\n      // is not shorter than the old one.\n      process.stdout.write(Console.CARRIAGE_RETURN);\n      self.messages.pop();\n      self.consecutiveRestartMessages ++;\n    } else {\n      self._clearSpecial();\n      self.consecutiveRestartMessages = 1;\n    }\n\n    var message = \"=> Meteor server restarted\";\n    if (self.consecutiveRestartMessages > 1)\n      message += \" (x\" + self.consecutiveRestartMessages + \")\";\n    // no newline, so that we can overwrite it if we get another\n    // restart message right after this one\n    process.stdout.write(message);\n\n    self._record({\n      time: new Date,\n      message: message\n    });\n  },\n\n  logClientRestart: function () {\n    var self = this;\n\n    if (self.consecutiveClientRestartMessages) {\n      // replace old message in place. this assumes that the new restart message\n      // is not shorter than the old one.\n      process.stdout.write(Console.CARRIAGE_RETURN);\n      self.messages.pop();\n      self.consecutiveClientRestartMessages ++;\n    } else {\n      self._clearSpecial();\n      self.consecutiveClientRestartMessages = 1;\n    }\n\n    var message = \"=> Client modified -- refreshing\";\n    if (self.consecutiveClientRestartMessages > 1)\n      message += \" (x\" + self.consecutiveClientRestartMessages + \")\";\n    // no newline, so that we can overwrite it if we get another\n    // restart message right after this one\n    process.stdout.write(message);\n\n    self._record({\n      time: new Date,\n      message: message\n    });\n  },\n\n  finish: function () {\n    var self = this;\n\n    self._clearSpecial();\n  },\n\n  clearLog: function () {\n    var self = this;\n    self.messages = [];\n  },\n\n  getLog: function () {\n    var self = this;\n    return self.messages;\n  }\n});\n\n// Create a singleton instance of RunLog. Expose its public methods on the\n// object you get with require('./run-log.js').\nvar runLogInstance = new RunLog;\n_.each(\n  ['log', 'logTemporary', 'logRestart', 'logClientRestart', 'logAppOutput',\n   'setRawLogs', 'finish', 'clearLog', 'getLog'],\n  function (method) {\n    exports[method] = _.bind(runLogInstance[method], runLogInstance);\n  });\n"]}