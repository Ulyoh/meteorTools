{"version":3,"sources":["/tools/meteor-services/service-connection.js"],"names":[],"mappings":"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","file":"tools/meteor-services/service-connection.js.map","sourcesContent":["var Future = require(\"fibers/future\");\nvar _ = require(\"underscore\");\nvar isopackets = require('../tool-env/isopackets.js');\n\n// Wrapper to manage a connection to a DDP service. The main difference between\n// it and a raw DDP connection is that the constructor blocks until a successful\n// connection is made; you can't call methods or subscribe asynchronously (ie,\n// there's always a wait); and if the connection disconnects (with or without\n// error) while we're waiting on a method call or subscription, the\n// apply/subscribeAndWait call throws the given error. This functionality should\n// eventually end up in the DDP client in one form or another.\n//\n// ServiceConnections never reconnect once they have successfully negotiated the\n// DDP protocol: other than perhaps some initial attempts with the wrong\n// protocol selected, they use just one underlying TCP connection, and fail\n// fast.\n//\n// - endpointUrl: the url to connect to\n// - options:\n//   - headers: an object containing extra headers to use when opening the\n//              DDP connection\n//   - _dontPrintErrors: boolean\n//   ...and anything else you'd normally pass as options to DDP.connect\n//\nvar ServiceConnection = function (endpointUrl, options) {\n  var self = this;\n\n  var Package = isopackets.load('ddp');\n\n  // ServiceConnection never should retry connections: just one TCP connection\n  // is enough, and any errors on it should be detected promptly.\n  options = _.extend({}, options, {\n    // We found that this was likely to time out with the DDP default of 10s,\n    // especially if the CPU is churning on bundling (eg, for the stats\n    // connection which we start in parallel with bundling).\n    connectTimeoutMs: 30000,\n    // Disable client->server heartbeats for service connections.  Users with\n    // slow internet connections were seeing heartbeat timeouts because the\n    // heartbeats were buried behind large responses (eg\n    // https://github.com/meteor/meteor/issues/2777).\n    heartbeatInterval: 0,\n    retry: false,\n    onConnected: function () {\n      self.connected = true;\n      if (!self.currentFuture)\n        throw Error(\"nobody waiting for connection?\");\n      if (self.currentFuture !== connectFuture)\n        throw Error(\"waiting for something that isn't connection?\");\n      self.currentFuture = null;\n      connectFuture.return();\n    }\n  });\n\n  self.connection = Package['ddp-client'].DDP.connect(endpointUrl, options);\n\n  // Wait until we have some sort of initial connection or error (including the\n  // 10-second timeout built into our DDP client).\n  var connectFuture = self.currentFuture = new Future;\n  self.connection._stream.on('disconnect', function (error) {\n    self.connected = false;\n    if (error && error.errorType === \"DDP.ForcedReconnectError\") {\n      // OK, we requested this, probably due to version negotation failure.\n      //\n      // This ought to have happened before we successfully connect, unless\n      // somebody adds other calls to forced reconnect to Meteor...\n      if (connectFuture.isResolved())\n        throw Error(\"disconnect before connect?\");\n      // Otherwise, ignore this error. We're going to reconnect!\n      return;\n    }\n    // Are we waiting to connect or for the result of a method apply or a\n    // subscribeAndWait? If so, disconnecting is a problem.\n    if (self.currentFuture) {\n      var fut = self.currentFuture;\n      self.currentFuture = null;\n      fut.throw(error ||\n                new Package['ddp-client'].DDP.ConnectionError(\n                  \"DDP disconnected while connection in progress\"));\n    } else if (error) {\n      // We got some sort of error with nobody listening for it; handle it.\n      // XXX probably have a better way to handle it than this\n      throw error;\n    }\n  });\n  connectFuture.wait();\n};\n\n_.extend(ServiceConnection.prototype, {\n  call: function (name, ...args) {\n    return this.apply(name, args);\n  },\n\n  apply: function (...args) {\n    var self = this;\n\n    if (self.currentFuture)\n      throw Error(\"Can't wait on two things at once!\");\n    self.currentFuture = new Future;\n\n    args.push(function (err, result) {\n      if (!self.currentFuture) {\n        // We're not still waiting? That means we had a disconnect event. But\n        // then how did we actually get this result?\n        throw Error(\"nobody listening for result?\");\n      }\n      var fut = self.currentFuture;\n      self.currentFuture = null;\n      fut.resolver()(err, result);  // throw or return\n    });\n\n    self.connection.apply(...args);\n\n    return self.currentFuture.wait();\n  },\n\n  // XXX derived from _subscribeAndWait in ddp_connection.js\n  // -- but with a different signature..\n  subscribeAndWait: function (...args) {\n    var self = this;\n\n    if (self.currentFuture)\n      throw Error(\"Can't wait on two things at once!\");\n    var subFuture = self.currentFuture = new Future;\n\n    args.push({\n      onReady: function () {\n        if (!self.currentFuture) {\n          // We're not still waiting? That means we had a disconnect event. But\n          // then how did we actually get this result?\n          throw Error(\"nobody listening for subscribe result?\");\n        }\n        var fut = self.currentFuture;\n        self.currentFuture = null;\n        fut.return();\n      },\n      onError: function (e) {\n        if (self.currentFuture === subFuture) {\n          // Error while waiting for this sub to become ready? Throw it.\n          self.currentFuture = null;\n          subFuture.throw(e);\n        }\n        // ... ok, this is a late error on the sub.\n        // XXX handle it somehow better\n        throw e;\n      }\n    });\n\n    var sub = self.connection.subscribe(...args);\n    subFuture.wait();\n    return sub;\n  },\n\n  close: function () {\n    var self = this;\n    if (self.connection) {\n      self.connection.close();\n      self.connection = null;\n    }\n  }\n});\n\nmodule.exports = ServiceConnection;\n"]}